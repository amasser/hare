package main

import (
	"fmt"
	"os/exec"
	"time"

	"github.com/jameycribbs/hare"
)

// BEGINNING OF ALL YOU NEED TO IMPLEMENT TO USE HARE

type record struct {
	ID               int       `json:"id"`
	Season           int       `json:"season"`
	Episode          int       `json:"episode"`
	Film             string    `json:"film"`
	Shorts           []string  `json:"shorts"`
	YearFilmReleased int       `json:"year_film_released"`
	DateEpisodeAired time.Time `json:"date_episode_aired"`
	Host             string    `json:"host"`
}

func (r *record) GetID() int {
	return r.ID
}

func (r *record) SetID(id int) {
	r.ID = id
}

func (r *record) AfterFind() {
	*r = record(*r)
}

type model struct {
	*hare.Table
}

func (mdl *model) query(queryFn func(rec record) bool, limit int) ([]record, error) {
	var results []record
	var err error

	for _, id := range mdl.Table.IDs() {
		r := record{}

		err = mdl.Table.Find(id, &r)
		if err != nil {
			panic(err)
		}

		if queryFn(r) {
			results = append(results, r)
		}

		if limit != 0 && limit == len(results) {
			break
		}
	}

	return results, err
}

// END OF ALL YOU NEED TO IMPLEMENT TO USE HARE

func main() {
	var mdl model

	setupExampleDB()

	//
	// Open the database and return a handle to it.
	//
	db, err := hare.OpenDB("data")
	if err != nil {
		panic(err)
	}
	defer db.Close()

	//
	// Let's grab a handle to the MST3K Episodes table so we can play with it.
	//
	mdl.Table, err = db.GetTable("mst3k_episodes")
	if err != nil {
		panic(err)
	}

	//
	// Now we will run a query for episodes that Joel hosted.
	//
	results, err := mdl.query(func(r record) bool {
		return r.Host == "Joel"
	}, 0)
	if err != nil {
		panic(err)
	}

	for _, r := range results {
		fmt.Println("Joel hosted:", r.Film)
	}

	//
	// If we know the ID, we can directly find an individual record.
	//
	rec := record{}

	err = mdl.Table.Find(3, &rec)
	if err != nil {
		panic(err)
	}

	fmt.Println("Record for ID 3:", rec.Film)

	//
	// Here's how to create a new record. Notice that we do NOT supply an ID
	// because this will be automatically generated by Hare when it creates
	// the record.
	//
	rec = record{
		Season:           6,
		Episode:          19,
		Film:             "Red Zone Cuba",
		Shorts:           []string{"Speech:  Platform, Posture, and Appearance"},
		YearFilmReleased: 1966,
		DateEpisodeAired: time.Date(1994, 12, 17, 0, 0, 0, 0, time.UTC),
		Host:             "Mike",
	}

	recID, err := mdl.Table.Create(&rec)
	if err != nil {
		panic(err)
	}

	err = mdl.Table.Find(recID, &rec)
	if err != nil {
		panic(err)
	}

	fmt.Println("Newly created record:", rec)

	//
	// Here's how to update a record.  If you take a look inside
	// ./data/mst3k_episodes.json after running this example program
	// you will see a line of "X"'s right above the line holding
	// the "Red Zone Cuba - The Final Cut" line.  That is called a
	// dummy record in Hare, and it gets created when Hare has to update
	// a record and the changes have increased the record length.  Hare
	// "dummies" out the old version of the record and writes the newer,
	// longer version at the bottom of the file.  Hare will attempt to
	// re-use the dummy record's space the next time it needs to create
	// a new record, if the new record will fit on that line.
	//

	rec.Film = "Red Zone Cuba - The Final Cut"

	if err = mdl.Table.Update(&rec); err != nil {
		panic(err)
	}

	err = mdl.Table.Find(recID, &rec)
	if err != nil {
		panic(err)
	}

	fmt.Println("Newly updated record:", rec)

	//
	// Here is how to delete a record.
	//
	err = mdl.Table.Destroy(2)
	if err != nil {
		panic(err)
	}

	err = mdl.Table.Find(2, &rec)
	if err == nil {
		panic(err)
	}

}

func setupExampleDB() {
	cmd := exec.Command("cp", "data/mst3k_episodes_default.json", "data/mst3k_episodes.json")
	if err := cmd.Run(); err != nil {
		panic(err)
	}
}
